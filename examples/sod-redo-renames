#!/bin/bash
# This file is part of sod.
#
# Copyright (C) 2022 Martin Kampas <martin.kampas@ubedi.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -o nounset
set -o pipefail

usage()
{
	cat <<'END'
usage: sod-redo-renames [--keep-empty-dirs] <old-commit> [<new-commit>]

This tool generates a shell script suitable for re-doing file renames recorded 
under a 'sod' repository within the given commit range.

It can be used to assist file transfer tools that do not handle file renames 
efficiently on their own. This is also the case of the famous rsync tool.

As an example consider a sod repository at path '/data' and its backup located 
on a different machine. Run sod-redo-renames on the original repository, 
passing the latest backed up revision as <old-commit>. Then run the generated 
shell script on the backup to reproduce the renames and as last step use rsync 
to transfer the remaining changes (file additions, removals etc.). It our 
example the backup machine does not allow remote connections, so we will 
invoke all commands from the backup side.

	# enter the backup directory
	backup $ cd data
	# determine the latest backed up commit ID
	backup $ since=$(< .sod/refs/heads/master)
	# generate the script to re-do renames since then
	backup $ ssh source "cd /data && sod-redo-renames '$since'" >rename.sh
	# review what would be done
	backup $ vim rename.sh
	# re-do renames
	backup $ bash rename.sh
	# transfer other changes
	backup $ rsync -av --delete source:/data/ .

OPTIONS
	--keep-empty-dirs
		Normally if renaming (moving) files leaves an empty directory, the 
		directory is removed.  This option prevents that.
END

}

bad_usage()
{
	cat >&2 <<END
sod-redo-renames: $*
Try 'sod-redo-renames --help' for more information.
END
}

do_rename()
{
	local src=$1 dst=$2

	local ok=
	trap '[[ $ok ]] || ALL_OK=' RETURN

	local src_dir=$(dirname "$src")
	local dst_dir=$(dirname "$dst")

	mkdir --verbose --parents "$dst_dir" || return
	mv --verbose "$src" "$dst" || return

	if [[ ! $OPT_KEEP_EMPTY_DIRS ]]; then
		rmdir --ignore-fail-on-non-empty --verbose --parents "$src_dir"
	fi

	ok=1
}

make_script()
{
	cat <<END
#!/bin/bash
# Generated by: $0 ${OPT_ORIG_ARGS[*]@Q}

set -o nounset
set -o pipefail

ALL_OK=1

END

	declare -p OPT_KEEP_EMPTY_DIRS
	declare -f do_rename
	printf '\n'

	sod diff --raw --null-terminated --filter=R "${OPT_RANGE[@]}" \
		|xargs -0 -n 3 bash -c 'printf "do_rename %q %q\n" "$2" "$3"' -

	cat <<'END'

if [[ ! $ALL_OK ]]; then
	printf 'Some files could not be renamed\n' >&2
	exit 1
fi
END
}

set_defaults()
{
	OPT_RANGE=()
	OPT_KEEP_EMPTY_DIRS=
	OPT_USAGE=
	OPT_ORIG_ARGS=()
}

parse_opts()
{
	OPT_ORIG_ARGS=("$@")

	while (($# > 0)); do
		case $1 in
			-h|--help)
				OPT_USAGE=1
				return
				;;
			--keep-empty-dirs)
				OPT_KEEP_EMPTY_DIRS=1
				;;
			--)
				shift
				positionals+=("$@")
				break
				;;
			-*)
				bad_usage "Unrecognized option: '$1'"
				return 1
				;;
			*)
				positionals+=("$1")
				;;
		esac
		shift
	done

	if ((${#positionals[*]} < 0 || ${#positionals[*]} > 2)); then
		bad_usage "One or two positional arguments expected"
		return 1
	fi

	OPT_RANGE=("${positionals[@]}")
}

main()
{
	set_defaults || return
	parse_opts "$@" || return

	if [[ $OPT_USAGE ]]; then
		usage
		return
	fi

	make_script
}

main "$@"
